import agents.interfaces.Do
import agents.interfaces.IGetThread
import agents.interfaces.PullMessage
import agents.interfaces.SendMessage
import agents.interfaces.StateAction
import agents.interfaces.StateMemory
import environnement.interfaces.ContextInfos
import environnement.interfaces.EnvUpdate
import generalStructure.interfaces.CycleAlert
import generalStructure.interfaces.ICreateAgent
import trace.Action
import environnement.interfaces.EnvInfos
import agents.interfaces.TransAction
import agents.interfaces.TransMemory
import generalStructure.interfaces.ILog

namespace general{

	ecosystem EcoAgents/*[ActionableState, ActionableTransition, ContextSA, ContextTA, ContextUpdate, StateSharedMemory, TransSharedMemory, Push, Pull] */{
		requires threads: IGetThread
		requires createAgent: ICreateAgent
		requires finishedCycleForLog: ILog
		
		species StateAgent (id: String, isRoot: boolean) {
			provides cycle: Do = agentComponent.cycle
			provides create: ICreateAgent
			requires getContext: ContextInfos
			requires setContext: EnvUpdate
			requires finishedCycle: CycleAlert
			requires push: SendMessage
			requires pull: PullMessage
			
			 part agentComponent: Agent[ContextInfos, EnvUpdate, StateAction, StateMemory, ICreateAgent, SendMessage, PullMessage] {
			 	bind getContext to getContext
			 	bind setContext to setContext
			 	bind finishedCycle to finishedCycle
			 	bind push to push
			 	bind pull to pull
			 	bind create to create
			 }
						
			//requires getTraceElement: IGetAction
		}
		
		species TransitionAgent(id:String, action:Action , stateSource:String) {
			
			provides cycle: Do = agentComponent.cycle
			provides create: ICreateAgent
			requires getContext: EnvInfos
			requires setContext: EnvUpdate
			requires finishedCycle: CycleAlert
			requires push: SendMessage
			requires pull: PullMessage
			
			part agentComponent: Agent[EnvInfos, EnvUpdate, TransAction, TransMemory, ICreateAgent, SendMessage, PullMessage] {
				bind getContext to getContext
			 	bind setContext to setContext
			 	bind finishedCycle to finishedCycle
			 	bind push to push
			 	bind pull to pull
			 	bind create to create
			}
		}
	}
	
	component Agent[Context, ContextUpdate, Actionable, SharedMemory, CreateAgent, Push, Pull] {

		part memory: Memory[SharedMemory]
		
		part perceive: Perceive[Context, SharedMemory, Pull] {
			bind decision to decide.decision
			bind getContext to getContext
			bind memory to memory.infos
		}
			
		part decide: Decide[Actionable, SharedMemory] {
			bind action to act.action
			bind memory to memory.infos
		}
	
		part act: Act[Actionable,ContextUpdate, SharedMemory, CreateAgent, Push] {
			bind finishedCycle to finishedCycle
			bind setContext to setContext
			bind memory to memory.infos
			bind create to create
		}
		
		provides cycle: Do = perceive.perception
		requires getContext: Context
		requires setContext: ContextUpdate
		requires finishedCycle: CycleAlert
		requires push: Push
		requires pull: Pull
		requires create: CreateAgent
	}
	
	component Perceive[Context, SharedMemory, Pull] {
		provides perception: Do
		requires decision: Do
		requires getContext: Context
		requires memory: SharedMemory
	}
	
	component Decide[Actionable, SharedMemory] {
		provides decision: Do
		requires action: Actionable
		requires memory: SharedMemory
	}
	
	component Act[Actionable, ContextUpdate, SharedMemory, CreateAgent, Push] {
		provides action: Actionable
		requires finishedCycle: CycleAlert
		requires setContext: ContextUpdate
		requires memory: SharedMemory
		requires create: CreateAgent
	}
		
	component Memory[SharedMemory] {
		provides infos: SharedMemory
	}
	
}